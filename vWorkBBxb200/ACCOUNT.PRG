// Berry Pay System
//    Storing payment summary records.  These print on Cheque Advice
//    and Weekly statements.
//
// started June 25, 1994
// account.prg
// Bill Hepler
//  Nov 2001 - minor change BH
//  July 2014 - changes for GST, and also possible to edit transactions
//              which are unposted & legal to edit, but have been added
//              fairly recently.
// July 24, 2014 - Made it so ALL ACCOUNT records have a unique ID in
//                 ACCT_UNIQ
// Sep 10,2019   - Change screen a little improve audit etc...
// May 18,2021   - Minor change to some text in May 2021

#include 'window.ch'
#include 'browser.ch'
#include 'valid.ch'
#include 'account.ch'
#include 'bsgstd.ch'
#include 'BerryPay.ch'
#include 'sysvalue.ch'
#include 'common.ch'
#include "field.ch"
#include "indexord.ch"
#include "price.ch"
#include 'inkey.ch'
#include 'errors.ch'

function AddAccount( nGrower, lQuestNeeded )
	local lAdd := .t.
	local cCurrency
	local nAcct_Uniq
	DEFAULT lQuestNeeded to .t.

	if lQuestNeeded
		lAdd := yesno({'Add a Transaction for this Grower?'})
	endif

	if lAdd
		if ValidTest(V_GROWER, nGrower, VT_MESSAGE)
			cCurrency := Grower->currency
			if empty(cCurrency)
				cCurrency := CANADIAN_DOLLARS
				waitInfo({'Check currency for this grower!'})
			endif
			nAcct_Uniq := NextAcctUniq( )

			if Account->(addRecord())

				Account->number := nGrower
				Account->date   := date()
				Account->year   := sysValue(SYS_CURRENT_YEAR)
				Account->type   := TT_MISCELLANEOUS
				Account->currency := cCurrency

				Account->acct_uniq := nAcct_Uniq    // July 24, 2014
	         AccountView( .t. , .t. )  // New Add
			endif
		endif
	endif

return( SIG_REDRAW )

function AllowAccEd()
	local lReturn := .f.
	// we used to restrict you from editing transactions over 60 days old.
	// we now make it 65 days and also allow you to edit transactions that
	// were Physically added within the last 45 days.

	if num2Equal0( Account->cheque ) .and. ;
		validtest(V_MAY_ADD_TRANSACTION_TYPE, Account->type, VT_NO_MESSAGE) ;
     .and. (Account->date >= date()-65 .or. ;
	            (!empty( Account->qadd_date) .and. date() <= Account->qadd_date+45) )

		lReturn := .t.
	endif
return( lReturn )


function AccountView( lAllowEdit, lNewAdd  )
	local aWin,getList:={}, lRead:= .f.
   local nAmt, nGstAmt, nNonGSTamt
	local aAcctRelStru, aDBF
	local lAddGSTtrn := .f.
	local nTrn
	local nAcct_Uniq, nGrower
	local dDate

	default lNewAdd to .f.

	if !Account->(recLock())
		return( SIG_CONTINUE )
	endif

   nAmt    := Account->Dollars
	nGstAmt := Account->Gst_Est
	nTrn    := Account->acct_uniq
	create window at 4,03,22,76 title 'Viewing Transaction #'+lStrim(Account->acct_uniq) to aWin
	display window aWin
	set cursor on

	// we can change Data ONLY if it has not been paid, and was not
	// generated by a computerized action.

	aAcctRelStru := ARRAY_REL_2_ACCOUNT
	AccountRelations( aAcctRelStru )

	if AllowAccEd() .and. lAllowEdit
		lRead := .t.
	endif
	nGrower := Account->number

	do while .t.
		SayLookups( aWin )

   	in window aWin  @  2, 2 winsay "Grower"
   	in window aWin  @  2,19 winsay Account->Number PICTURE "9999"
   	in window aWin  @  2,30 winsay NameOf(LU_GROWER,Account->number)

   	in window aWin  @  3, 2 winsay "Crop Year"
   	in window aWin  @  3,18 winGet Account->Year PICTURE "9999" valid ;
   	 validAcctYear( Account->year, VT_MESSAGE)

		do case
      case !empty( Account->ADV_NO ) .and. !empty( Account->adv_bat )
         in window aWin  @ 16, 2 winsay 'Advance # '+ var2char(Account->ADV_NO) + '   Batch:'+ var2char( Account->adv_bat)
      case !empty( Account->FIN_BAT )
         in window aWin  @ 16, 2 winsay 'Final Payout Batch No:'+ var2char( Account->fin_bat)
      endcase

		in window aWin  @ 17, 2 winsay 'Unique ID: '  + ;
        padl(iif( empty(Account->Acct_uniq),'Not Assigned', ;
         lStrim(Account->Acct_uniq)),12)

   	in window aWin  @ 18, 2 winsay 'Cheque Number: ' + ;
       aAcctRelStru[ REL_2_CHEQUE_FULL_ID ]

   	in window aWin  @ 19, 2 winsay 'Chq Info: ' + aAcctRelStru[ REL_2_CHEQUE_INFO ]

		do case
		case aAcctRelStru[  REL_2_IS_ERROR  ]
			in window aWin  @ 17,33 winsay padr(aAcctRelStru[  REL_2_ERROR_CONDITION    ], 40)
			in window aWin  @ 18,33 winsay space( 40)
		case aAcctRelStru[ REL_2_STANDALONE ]
			in window aWin  @ 17,33 winsay padr('Not tied to other transactions', 40)
			in window aWin  @ 18,33 winsay space( 40 )
		otherwise
			in window aWin  @ 17,33 winsay padr( iif(aAcctRelStru[ REL_2_ACCOUNT_TRN_DAILY ], ;
   			'Relates to Scale Tickets','Not pulled from scale tickets'),40)
			do case
			case !aAcctRelStru[ REL_2_OTHER_ACCOUNTS_AS_MASTER ] .and. ;
			     !aAcctRelStru[ REL_2_OTHER_ACCOUNTS_AS_CHILD ]
				in window aWin  @ 18,33 winsay space(40)  // no comment
			case aAcctRelStru[ REL_2_OTHER_ACCOUNTS_AS_MASTER ] .and. ;
			     aAcctRelStru[ REL_2_OTHER_ACCOUNTS_AS_CHILD ]
				in window aWin  @ 18,33 winsay padr( 'Complex relation to other ACCOUNT data',40)
			case aAcctRelStru[ REL_2_OTHER_ACCOUNTS_AS_MASTER ]
				in window aWin  @ 18,33 winsay padr( 'Deduced from Account record(s)',40)     // note revised May 2021
			case aAcctRelStru[ REL_2_OTHER_ACCOUNTS_AS_CHILD ]
				in window aWin  @ 18,33 winsay padr( 'Used to calculate other Account records',40)
				//                                    123456789.123456789.123456789.123456789.
			otherwise
				in window aWin  @ 18,35 winsay padr( '--- ??? ---',35)
			endcase
		endcase

   	getList :={}

   	in window aWin  @  3, 2 winsay "Crop Year      "  ;
   	 winGet Account->Year PICTURE "9999" ;
   	 valid Account->year >= sysValue(SYS_CURRENT_YEAR)-1 ;
   	 .and. Account->year <= sysValue(SYS_CURRENT_YEAR)+1

   	in window aWin  @  4, 2 winsay "Date           "  winGet Account->Date ;
   	 valid validAcctDate(Account->date,VT_MESSAGE) ;
		 get_message 'Date of transaction - weekly cheque run will consider this'

      in window aWin  @  6, 2 winsay "Type           " winGet Account->Type ;
       PICTURE "@!" ;
       valid ValidTest( V_MAY_ADD_TRANSACTION_TYPE, Account->type, VT_MESSAGE) ;
       LOOKUP( LU_MAY_ADD_TRANSACTION_TYPE, "Input Valid Type of Transaction - [F5] to Browse")

		// Changed in July 2014
      // in window aWin  @  7, 2 winsay "Class          " winGet Account->Class ;
      //  PICTURE "@!" when Account->type==TT_DEDUCT .or. Account->type==TT_GST_TAX ;
      // valid ValidTest( V_DEDUCTION_CLASS, Account->class, VT_MESSAGE ) ;
      // LOOKUP( LU_DEDUCTION_CLASS,'Input Deduction Class - [F5] for list')
      in window aWin  @  7, 2 winsay "Class          " winGet Account->Class ;
        PICTURE "@!"  ;
       valid ValidTest( V_CLASS_FOR_A_TYPE, Account->class, VT_BROWSE, Account->type ) ;
       LOOKUP( LU_CLASS_FOR_A_TYPE,'Input Deduction Class - [F5] for list', Account->type)

      in window aWin  @  8, 2 winsay "Product        " winGet Account->product ;
       PICTURE "@!" valid ;
		 iif( empty(Account->product),.t. , ;
		   ValidTest( V_PRODUCT, Account->product, VT_BROWSE ) ) ;
       LOOKUP( LU_PRODUCT,'Input Product (if any) - [F5] for list')

      in window aWin  @  9, 2 winsay "Process        " winGet Account->process ;
       PICTURE "@!" valid ;
		 iif(empty(Account->process),.t. , ;
		   ValidTest( V_PROCESS_TYPE, Account->process, VT_BROWSE )  ) ;
       LOOKUP( LU_PROCESS_TYPE,'Input Process (if any) - [F5] for list')

      in window aWin  @ 10, 2 winsay "Grade          " winGet Account->grade   ;
       PICTURE "9" valid Account->grade <= MAX_NO_OF_GRADES ;
       get_message 'Enter grade if needed or leave blank'

      in window aWin  @ 11,02 winsay "Lbs.           " ;
       winGet Account->Lbs PICTURE "99999999" ;
       valid ExtUpdater( lRead ) ;
		 get_message 'This is for Information only'

      in window aWin  @ 11,33 winsay  "Unit Price   " ;
       winGet Account->U_price PICTURE "9999.99999" ;
       valid ExtUpdater( lRead ) ;
		 get_message 'This is for Information only'

      in window aWin  @ 12,02 winsay "Extended Price " ;
       winGet Account->Dollars ;
		 get_message ;
		  'This is the amount that adjusts the grower cheque' + ;
		   ' (Deductions = Negative!)'

      in window aWin  @ 12,33 winsay  "GST Estimate" ;
       winGet Account->Gst_Est when MayChgGSTonType( Account->type ) ;
		 get_message ;
		  'This is an Estimate of the GST (if this is GST taxable)'

      in window aWin  @ 13,02 winsay "Currency       " ;
       winGet Account->currency PICTURE "@!" ;
       valid validTest( V_CURRENCY, Account->currency, VT_MESSAGE ) ;
       get_message 'Enter Currency Type  (C/U)'

		in window aWin  @ 13,33 winsay  "NonGST base" ;
		 winGet Account->nongst_est when Account->type=TT_GST_TAX ;
       get_message 'Enter the Non GST (estimated) amount ONLY for GST tax'

      in window aWin  @ 14,02 winsay "Note           " ;
       winGet Account->Desc ;
       get_message 'This may print on cheque stubs & certain reports'

   	if lRead
   		read
			SayLookUps( aWin )

         if Num2Equal0(Account->dollars,12,2) .and. Num2Equal0( nGstAmt) .and. ;
            Num2Equal0(nAmt) .and.  Num2Equal0(Account->gst_Est) .and. lastkey()==K_ESC

            // probably we are "adding" by mistake
            if yesno({'Do you want to CANCEL OUT this transaction?', ;
                 '', ;
                 'Note - you may see this transaction as a sort' , ;
                 'of ghost transaction when you exit the screen.', ;
                 'The transaction will disappear - do not worry.'})
               Account->(dbDelete())
               exit
            endif
         endif

			// We "Fix" the GST in case it is Weird
			do case
			case Account->type == TT_GST_TAX
				if Num2NotEqual0( Account->Gst_est)
					Account->Gst_est := 0.00
					WaitInfo({'The GST estimate is relevant only for the Actual GST transactions', ;
					          'We have set the amount to ZERO.', ;
					          'This should be basis for the GST calculation itself.'})
				endif
			case !MayChgGSTonType( Account->type )
				if Num2NotEqual0( Account->gst_est)
					Account->gst_est :=  0.00
					in window aWin  @ 12,33 winsay  "GST Est.  " ;
					 winGet Account->Gst_Est
					WaitInfo({'We change the Estimated GST to ZERO', ;
					     'because this type of Transaction is NOT', ;
						  'GST taxable.'})
				endif
			case MayChgGSTonType( Account->type ) .and. lNewAdd .and. !lAddGSTtrn
				if Num2NotEqual0( Account->gst_est)
					if YesNo({'Do you wish to add a GST record after you complete', ;
					          'this transaction?', ;
								 'this new transaction will contain the ACTUAL GST', ;
								 'charge!'})
						lAddGSTtrn := .t.
					endif
				endif
			endcase

			if Account->type==TT_DEDUCT .and. Account->dollars >= 0
				waitInfo({'Usually DEDUCTIONS should be NEGATIVE !'})
			endif

			if !empty(Account->product)
				if !ValidTest(V_PRODUCT, Account->product, VT_MESSAGE)
					loop
				endif
				if !ValidTest(V_PROCESS_TYPE, Account->process, VT_MESSAGE)
					loop
				endif
				if Account->grade <= 0 .or. Account->grade > MAX_NO_OF_GRADES
					waitInfo({'Grade is empty-Product is not'})
					loop
				endif
			endif

			if !empty(Account->process)
				if !ValidTest(V_PRODUCT, Account->product, VT_MESSAGE)
					loop
				endif
				if !ValidTest(V_PROCESS_TYPE, Account->process, VT_MESSAGE)
					loop
				endif
				if Account->grade <= 0 .or. Account->grade > MAX_NO_OF_GRADES
					waitInfo({'Grade is empty-Process is not'})
					loop
				endif
			endif

			if (empty(Account->product) .or. empty(Account->process)) ;
					 .and. Account->Grade <> 0
				waitInfo({'Grade should be empty'})
				loop
			endif

         if !validTest( V_CURRENCY, Account->currency, VT_MESSAGE )
            WaitInfo({'Fix the currency!'})
            loop
         endif

			do case
			case !validAcctDate(Account->date,VT_MESSAGE) .or. ;
			  !validAcctYear(Account->year,VT_MESSAGE)
			 	loop
			// case Account->type<>TT_DEDUCT .and. !empty(Account->class)
   		// 	Account->class := ''
   		//	loop
   		// case Account->type==TT_DEDUCT .and. ;
   		//  !validTest(V_DEDUCTION_CLASS,Account->class,VT_MESSAGE)
   		//	loop
			case !ValidTest( V_CLASS_FOR_A_TYPE, Account->class, VT_MESSAGE, Account->type)
				waitInfo({'Hm-the Type of Transaction and the Class are not' , ;
				          'in agreement'})
   		case Account->type==TT_MISCELLANEOUS .and. empty(Account->desc)
         	waitInfo({'Please tell us why you are doing this!'})
         	loop
         case year(Account->date) < Account->year
         	waitInfo({'Date of transaction is BEFORE the crop year!'})
         	loop
         endcase
			Account->(dbCommit())

   	else
   		getList :={}

         ShowRelatedDaily()   // New In Sep 2019

   		thinWait('Press any Key')
   	endif
   	exit
   enddo
   kill window aWin

	Account->(dbUnlock())

	if lAddGstTrn
		nGSTamt     := Account->gst_est
		nNonGSTamt  := Account->dollars
		dDate       := Account->date

		if Yesno({'Add the GST transaction?', ;
		          'Estimated GST is: '+DollarStr( nGSTamt, 12) })

			aDBF := Account->(saveDBF())
			nAcct_Uniq	:= NextAcctUniq( )
			Account->(restDBF( aDBF ))

			if Account->(addRecord())

				Account->number := nGrower
				Account->date   := dDate
				Account->year   := sysValue(SYS_CURRENT_YEAR)
				Account->type   := TT_GST_TAX
				Account->class  := TAX_TYPE_CL_RELATES_TO_ANOTHER
				Account->currency := CANADIAN_DOLLARS
				Account->dollars     := nGSTamt
				Account->nonGst_est  := nNonGSTamt
				Account->acct_uniq := nAcct_Uniq    // July 24, 2014

				if num2NotEqual0( nTrn )
					Account->desc     := 'See also Trn# '+lStrim(nTrn)
				else
					appError( APP_ERR_ACCT_UNIQ_6, ;
					  {'We have an ACCOUNT DBF transaction without a Uniq ID', ;
					   'Please get Crafted Industrial Software Ltd. to fix', ;
						'this transaction.  Relates to Recno='+lstrim(Account->(recno())), ;
						'Not a critical problem, but you should fix it!'})
				endif
				Account->(dbCommit())
				Account->(dbUnLock())

				// We Add the Audit Records
				if AudAcct->(addRecord())
					AudAcct->acct_uniq := nAcct_Uniq // the GST is a Master because
					AudAcct->acct_child := nTrn      // there can be more than one child
					AudAcct->(dbCommit())
					AudAcct->(dbUnLock())
				endif
				WaitInfo({'You should check over this new record', ;
				          'It estimates the tax to be: '+DollarStr(Account->dollars,12) })
			endif

		endif
	endif

return( SIG_REDRAW )

static function ExtUpdater( lRead )

   if lRead
      do case
      case str(Account->dollars,12,3)==str(0,12,3) .and. ;
         str(Account->Lbs,12,3) <> str(0,12,3) .and. ;
         str(Account->u_price,12,3) <> str(0,12,3)

         Account->Dollars := round( Account->lbs * Account->u_price, 2)

      case str(Account->dollars,12,3)<>str( ;
         round( Account->lbs * Account->u_price, 2),12,3) .and. ;
         str(Account->Lbs,12,3) <> str(0,12,3) .and. ;
         str(Account->u_price,12,3) <> str(0,12,3)

         if yesno( {'Update the Extended Price based on Unit Price and', ;
                    'the weight entered?'})
            Account->Dollars := round( Account->lbs * Account->u_price, 2)
         endif
      endcase
   endif
return( .t. )

static function SayLookups( aWin )
	in window aWin  @  6,33 winsay NameOf(LU_TRANSACTION_TYPE,Account->type)
	in window aWin  @  7,33 winsay NameOf(LU_ALL_ACCOUNT_CLASSES,Account->class)
	in window aWin  @  8,33 winsay NameOf(LU_PRODUCT,Account->product)
	in window aWin  @  9,33 winsay NameOf(LU_PROCESS_TYPE ,Account->process)
	if MayChgGSTonType( Account->type )
		in window aWin  @ 12,54 winsay DollarStr( Account->dollars + Account->Gst_Est,15)
	else
		in window aWin  @ 12,54 winsay space( 15)
	endif
	in window aWin  @ 13,24 winsay padl(NameOf(LU_CURRENCY ,Account->currency),6)
return( .t.  )

///<summary>Shows DAILY.DBF that relate to this ACCOUNT.DBF record</summary>
static function ShowRelatedDaily()
	local aDBF1, aDBF2
   local aDaily := {}  //
   local oTb, oCol
   local nRowArray
   local aMsg

   if Account->acct_uniq >= 1     // i.e. there is something to look at
   	aMsg := msgLine('Looking for related Scale Ticket transactions....')

      aDBF1 := Daily->( saveDBF())
      aDBF2 := Account->( saveDBF())

      Daily->( ordSetFocus( DAILY_ID_ORD ))
      Audit->( ordSetFocus( AUDIT_ACCT_DAY_ORD ))

      Audit->( dbSeek( str( Account->acct_uniq, FLD_DOCUMENT ), HARDSEEK ))
      do while Audit->acct_uniq == Account->acct_uniq .and. !Audit->(eof())

      	// Now look for records in Daily table
         Daily->( dbSeek( str( Audit->day_uniq, FLD_DOCUMENT ), HARDSEEK ))
         do while Daily->day_uniq == Audit->day_uniq .and. !Daily->(eof())
         	aadd( aDaily, { str( Daily->recpt, FLD_DOCUMENT) + ;
				                Daily->recptltr      + ' '  + ;
                            shMdy( Daily->date ) + '  ' + ;
                            Daily->product       + ' '  + ;
                            Daily->process       +        ;
                            str( Daily->grade,2) + ' '  + ;
                            transform( Daily->net,'9,999,999')    ,   Daily->(recno()) } )

         	Daily->(dbSkip())
         enddo
      	Audit->(dbSkip())
      enddo

      rest_scr( aMsg )

      if len( aDaily ) == 0
      	// Equity, Miscellaneous etc are manually keyed in transactions usually, so we do NOT worry
      	if !( Account->type  $  TT_EQUITY + 'k' + TT_MISCELLANEOUS + 'k' + TT_DEDUCT + 'k' + TT_GST_TAX )

	      	WaitInfo({'This transaction does NOT seem to relate to any individual', ;
                      'tickets.'})
         endif
		else

			oTb       := tBrowCreate(4,10)
			nRowArray := 1
			oCol      := tbcolCreate('Ticket Information',{|| aDaily[nRowArray,1 ] })
			tbColAdd(oTb, oCol)

			//	 **** The next line is important, note the @

			tbMainCfg( oTb, CB_GOTOP,	  {|| nRowArray := 1})
			tbMainCfg( oTb, CB_GOBOTTOM, {|| nRowArray := len(aDaily) })
			tbMainCfg( oTb, CB_WHILE,    {|| nRowArray >=1 .or. nRowArray <= len(aDaily) })

         //                              the record numberof this Daily Record
         tbKeyCfg( oTb, {K_ENTER,     {|| LookAtDaily( aDaily[ nRowArray, 2] ) }})
			tbKeyCfg(oTb,  { K_ALT_P,    {||PrintTb(oTb)   } } )

			tbMainCfg( oTb, CB_SKIP,     {| n | ArraySkipper( n, @nRowArray, aDaily )})

			tbMainCfg( oTb, CB_ALLOW_EDIT, .f.)
			tbMainCfg( oTb, CB_NEED_LOCKS, .f. )
         tbMainCfg( oTb, CB_TITLE,   'Receipts relating to '+ Account->type+'-'+ lstrim( Account->acct_uniq) )
			tbMainCfg( oTb, CB_MESSAGE, '[Enter] for Receipt Detail   [Alt P] to Print Browse' )
			theBrowse(oTB, SHO_CLEAR_ON_EXIT)

      endif
	   Daily->( restDBF( aDBF1 ))
	   Account->( restDBF( aDBF2 ))
	endif

return( nil )

static function LookAtDaily( nRecNo  )
	// we DO NOT care if we move the Record pointer as we will reset it Later

	if nRecNo > 0
   	Daily->(dbGoTo( nRecNo ))

      if Daily->( recLock( .t. ))
      	DailyEdit( DAILY_EDIT_VIEW_ONLY, Account->number )    // if NOT posted, we can edit...
      endif
   endif

return(  SIG_CONTINUE )
